# Learn Makefiles - Notes

from https://makefiletutorial.com/#makefile-cookbook \
by Chase Lambert @ [chaselambda.com](https://chaselambda.com/)

## Getting Started

### Purpose

- determine which parts of a program need to be recompiled
- execute instructions based on which files have changed

### Running `make`

- name the file `Makefile`
- run `make` from the directory where `Makefile` lives
- makefiles must be indented by tabs

### Syntax

a makefile consist of a set of rules, each following the structure :
```make
target1 target2 target3 : prerequisite1 prerequisite2 prerequisite3
	command 1
	command 2
	command 3 # this is a comment
	...
```

- `targets` are filenames, separated by spaces
	- typically, there's only one per rule
- `command`s are a series of steps usually used to make the `targets`
- `prerequisites` are also filenames separated by spaces. they need to exist
  before the `command`s for the `target` are run

### Essence

- the commands in a rule only run if the file does not exist or if a dependency
  has been updated
- if no target is supplied as an argument, `make` will simply execute the rules
  in `Makefile`, in sequence
- `make` uses filesystem timestamps to determine execution of rules with updated
  dependencies

### Make Clean

- `clean` is often used as a target to remove the output generated by other
  targets
- since it should never be listed first nor should it ever be a prerequisite,
  it will never run unless it is explicitly invoked by `make clean`
- it is not intended to be an actual filename

### Variables

- variables can only be strings
- using `:=` is preferable over `=` but will work just as well
```make
dependencies := fileA fileB fileC

fileD: $(dependencies)
	commands...
```
- quotes have no meaning in make, yet are only useful to bash
- it is recommended that quotes not be used when assigning variables
- variables can be referenced by ether `${}` or `$()`, but referencing variables
  solely with `$` will work nonetheless

## Targets

- using `all` as the first rule without any commands, permits running multiple
  targets to run
```make
all: file1 file2 file3
```

- if multiple targets are provided to a single rule, then the given commands
  will run for each one listed
	- each target iteration is referenced by the automatic variable `$@`

## Automatic Variables and Wildcards

### `*` Wildcard

- this wildcard will search the filesystem for matching names and should be
  wrapped in the wildcard function `$(wildcard *.c)`
- it can be used within the target, prerequisites, or by the `wildcard` function
- **caution** : it should not be directly used in variable definitions
- **caution** : if `*` matches no files, it will be interpreted as a string, unless the
  `wildcard` function is used

### `%` Wildcard

- this wildcard can be used in various 'modes'
- in 'matching' mode, it will match one or more characters in a given string
  known as the 'stem'
- in 'replacing' mode, it takes the matching stem and replaces it within a
  string
- it is most often used in rule (variable?) definitions within specific
  functions

### Automatic Variables

- `$@` references the each target given in a rule
- `$?` references all prerequisites newer than the target
- `$^` references all prerequisites
- `$<` references the first prerequisite

## Fancy Rules

#### Implicit Rule Variables

implicit rules make use of special user defined variables

- `CC`: the c compiler program
- `CXX`: the c++ compiler program
- `CFLAGS`: default flags to give to the c compiler
- `CXXFLAGS`: default flags to give to the c++ compiler
- `CPPFLAGS`: default flags to give to the c pre-processor
- `LDFFLAGS`: default flags to give to the compilers when invoking the linker

### Implicit Rules

- c program compilation:
  `$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@`
	- creates `.o` files from `.c` files
- c++ program compilation:
  `$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@`
	- creates `.o` files from `.cc` or `.cpp` files
- linking a single object file:
 `$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@`
	- creates the final object file from `.o` files

example :

```make
CC = gcc
CFLAGS = -g

# implicitly builds foo.o via the c compilation rule, if foo.c exist
# implicitly builds foo via the c linking rule
foo: foo.o

# ...
```

### Static Pattern Rules
#### Filter
### Pattern Rules
### Double-Colon Rules

## Commands and Execution

### Echoing and Silencing
### Execution
### Default Shell
### `$$`
### Error Handling
### Interrupting and Killing
### Recursive Usage
### Export, Environments, and Recursive Make
### Arguments

## Variables Pt. 2

### Flavors and Modifications
### Commandline Arguments and Override
### List of Commands and Define
### Target-specific Variables
### Pattern-specific Variables

## Conditional part of Makefiles

### if/else
### Check Empty Variable
### Check Defined Variable
### `$(MAKEFLAGSS)`

## Functions

### First Functions
### String Substitution
### `foreach` Function
### `if` Function
### `call` Function
### `shell` Function
### `filter` Function

## Additional Features

### Include Makefiles
### `vpath` Directive
### Multiline
### `.phony`
### `.delete_on_error`

## Makefile Cookbook

