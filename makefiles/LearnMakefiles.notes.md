# Learn Makefiles - Notes

from https://makefiletutorial.com/#makefile-cookbook \
by Chase Lambert @ [chaselambda.com](https://chaselambda.com/)

## Getting Started

### Purpose

- determine which parts of a program need to be recompiled
- execute instructions based on which files have changed

### Running `make`

- name the file `Makefile`
- run `make` from the directory where `Makefile` lives
- makefiles must be indented by tabs

### Syntax

a makefile consist of a set of rules, each following the structure :
```make
target1 target2 target3 : prerequisite1 prerequisite2 prerequisite3
	command 1
	command 2
	command 3 # this is a comment
	...
```

- `targets` are filenames, separated by spaces
	- typically, there's only one per rule
- `command`s are a series of steps usually used to make the `targets`
- `prerequisites` are also filenames separated by spaces. they need to exist
  before the `command`s for the `target` are run

### Essence

- the commands in a rule only run if the file does not exist or if a dependency
  has been updated
- if no target is supplied as an argument, `make` will simply execute the rules
  in `Makefile`, in sequence
- `make` uses filesystem timestamps to determine execution of rules with updated
  dependencies

### Make Clean

- `clean` is often used as a target to remove the output generated by other
  targets
- since it should never be listed first nor should it ever be a prerequisite,
  it will never run unless it is explicitly invoked by `make clean`
- it is not intended to be an actual filename

### Variables

- variables can only be strings
- using `:=` is preferable over `=` but will work just as well
```make
dependencies := fileA fileB fileC

fileD: $(dependencies)
	commands...
```
- quotes have no meaning in make, yet are only useful to bash
- it is recommended that quotes not be used when assigning variables
- variables can be referenced by ether `${}` or `$()`, but referencing variables
  solely with `$` will work nonetheless

## Targets

- using `all` as the first rule without any commands, permits running multiple
  targets to run
```make
all: file1 file2 file3
```

- if multiple targets are provided to a single rule, then the given commands
  will run for each one listed
	- each target iteration is referenced by the automatic variable `$@`

## Automatic Variables and Wildcards

### `*` Wildcard

- this wildcard will search the filesystem for matching names and should be
  wrapped in the wildcard function `$(wildcard *.c)`
- it can be used within the target, prerequisites, or by the `wildcard` function
- **caution** : it should not be directly used in variable definitions
- **caution** : if `*` matches no files, it will be interpreted as a string, unless the
  `wildcard` function is used

### `%` Wildcard

- this wildcard can be used in various 'modes'
- in 'matching' mode, it will match one or more characters in a given string
  known as the 'stem'
- in 'replacing' mode, it takes the matching stem and replaces it within a
  string
- it is most often used in rule (variable?) definitions within specific
  functions

### Automatic Variables

[10.5.3 Automatic Variables](https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html)

- `$@` references the each target given in a rule
- `$?` references all prerequisites newer than the target
- `$^` references all prerequisites
- `$<` references the first prerequisite

## Fancy Rules

#### Implicit Rule Variables

implicit rules make use of special user defined variables

- `CC`: the c compiler program
- `CXX`: the c++ compiler program
- `CFLAGS`: default flags to give to the c compiler
- `CXXFLAGS`: default flags to give to the c++ compiler
- `CPPFLAGS`: default flags to give to the c pre-processor
- `LDFFLAGS`: default flags to give to the compilers when invoking the linker

### Implicit Rules

- c program compilation:
  `$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@`
	- creates `.o` files from `.c` files
- c++ program compilation:
  `$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@`
	- creates `.o` files from `.cc` or `.cpp` files
- linking a single object file:
 `$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@`
	- creates the final object file from `.o` files

example :
```make
CC = gcc
CFLAGS = -g

# implicitly builds foo.o via the c compilation rule, if foo.c exist
# implicitly builds foo via the c linking rule
foo: foo.o

# ...
```

### Static Pattern Rules

syntax:
```make
targets: target-pattern: prereq-pattern ...
	commands
```
herein, the given `target` is matched by the `target-pattern` via the `%`
wildcard. the stem is whatever is matched, which is then substituted into the
`prereq-pattern` in order to generate the target's prerequisites

example:
```make
objects = foo.o bar.o baz.o

all: $(objects)
	$(CC) $^ -o nar

# the stem extracted by `%.o` is substituted into `%.c`
$(objects): %.o: %.c
	$(CC) -c $^ -o $@

```

- for rules, when there is more than one match, `make` will prioritize the most
  specific one

within static pattern rules, the `filter` function is in common usage. its
purpose is to match the correct files.

### Pattern Rules

- are a way to define custom implicit rules
- a simpler form of static pattern rules

pattern rules contain a `%` in the target. it matches any nonempty string while
the other characters match themselves. the `%` in the prerequisite substitutes
the matched stem

example:
```make
# a pattern rule that compiles every .c file into a .o file
%.o: %.c
	$(cc) -c $(cflags) $(cppflags) $< -o $@
```

### Double-Colon Rules

these allow multiple rules to be defined for the same target
```make
all: foo

foo::
	echo "hello"

foo::
	echo "hello, again"
```

## Commands and Execution

### Echoing and Silencing

- an `@` preceding a command will prevent printing it out
- alternatively, passing the `-s` flag to make will also silence the command
  printing

### Execution

- each command-line in a rule will run in it's own shell
- to run commands together they should be put on the same line
- to change the default shell set the `SHELL` variable to the binary's path

- in order to have a dollar sign in a string use `$$` - this is how variables
  are passed to the shell
```make
all:
	sh_var='hello, world'; echo $$sh_var
```

### Error Handling

- the `-k` flag will continue running regardless of errors
	- this is useful if you wish to see all errors generated
- adding `-` before a command will suppress its errors
- the `-i` flag will suppress errors for all commands
- `ctrl+c` will delete all the newest targets just created

### Recursive Usage

- in order to invoke a makefile use `$(MAKE)` since it will pass the proper
  flags

### Export, Environments, and Recursive Make

- when make is ran, it automatically creates make variables from the all the
  environment variables set when executed
- the `export` directive adds variables to the environment for subsequent
  sub-shells to use
	- this permits recursive calls to use previously defined variables
- `.EXPORT_ALL_VARIABLES:` exports all variables in a makefile

### Arguments

[9.8 summary of options](https://www.gnu.org/software/make/manual/make.html#Options-Summary)

notable ones would be `--dry-run`, `--touch`, and `--old-file`

multiple targets specified to make are run in sequence

## Variables Expanded

### Flavors and Modifications

- recursive (`=`) : searches for the variable when a command is invoked, not
  when it's defined
- simply expanded (`:=`) : as in imperative programming wherein only variables
  defined *thus far* get expanded
	- these allow for appending previously defined variables

- conditional (`?=`) : will only set a variable it has not been previously
  defined

- preceding white is trimmed, while trailing whitespace is not stripped
- use `nullstring =` to allow creating a variable with a single whitespace
	- `space = $(nullstring) `

- undefined variable evaluate to empty strings
- `+=` appends to a previously defined variable

#### Resources

- [string substitution](https://makefiletutorial.com/#string-substitution)
- [text functions](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions)
- [filename functions](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#File-Name-Functions)

### Commandline Arguments and Override

variables provided by the commandline  can be overwritten by using `override`
if make is invoked as `make option_A=hello` then it can be overwritten with
```make
override option_A = goodbye
```

### List of Commands and Define

`define` with `endef` is used to create a variable set to a list of commands

### Target-specific Variables

variables may be set for specific targets
```make
target: var = value
```
as well as for specific target patterns
```make
%.ext: boo = tar
```

## Conditional part of Makefiles

### if/else

```make
check = B

target:
ifeq ($(check), B)
	command set 1
else
	command set 2
endif
```

- use `ifeq ($(strip $(bar)),) ... endif` to check if a variable is empty
- use `ifdef` or `ifndef` to check whether a variable is defined

### `$(MAKEFLAGSS)`

## Functions

### First Functions
### String Substitution
### `foreach` Function
### `if` Function
### `call` Function
### `shell` Function
### `filter` Function

## Additional Features

### Include Makefiles
### `vpath` Directive
### Multiline
### `.phony`
### `.delete_on_error`

## Makefile Cookbook

